# Example values for OpenResty with additional Lua modules
# Copy this file and customize for your needs

replicaCount: 1

image:
  repository: openresty/openresty
  tag: "1.21.4.1-alpine"
  pullPolicy: IfNotPresent

# OpenResty specific configuration
openresty:
  # Lua modules to install
  modules:
    enabled: true
    # Install additional Lua modules via luarocks
    luarocks:
      - "lua-resty-auto-ssl" # Auto SSL with Let's Encrypt
      - "lua-resty-redis" # Redis client
      - "lua-resty-mysql" # MySQL client
      - "lua-resty-jwt" # JWT handling
      - "lua-resty-http" # HTTP client
      - "lua-resty-websocket" # WebSocket support
      - "lua-resty-limit-traffic" # Rate limiting
    # Custom modules from Git
    gitModules:
      - name: "lua-resty-consul"
        url: "https://github.com/hashicorp/lua-resty-consul.git"
        path: "/usr/local/openresty/lualib/resty/consul"
      - name: "lua-resty-kafka"
        url: "https://github.com/doujiang24/lua-resty-kafka.git"
        path: "/usr/local/openresty/lualib/resty/kafka"

  # Custom nginx.conf configuration
  config:
    enabled: true
    nginxConf: |
      user nginx;
      worker_processes auto;
      error_log /var/log/nginx/error.log warn;
      pid /var/run/nginx.pid;

      # Load dynamic modules
      load_module modules/ngx_http_lua_module.so;
      load_module modules/ngx_stream_lua_module.so;

      events {
          worker_connections 1024;
      }

      http {
          include /etc/nginx/mime.types;
          default_type application/octet-stream;

          log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                          '$status $body_bytes_sent "$http_referer" '
                          '"$http_user_agent" "$http_x_forwarded_for"';

          access_log /var/log/nginx/access.log main;

          sendfile on;
          tcp_nopush on;
          tcp_nodelay on;
          keepalive_timeout 65;
          types_hash_max_size 2048;

          # Lua configuration with all modules
          lua_package_path "/usr/local/openresty/lualib/?.lua;/usr/local/openresty/lualib/custom/?.lua;;";
          lua_package_cpath "/usr/local/openresty/lualib/?.so;;";
          
          # SSL configuration
          ssl_protocols TLSv1.2 TLSv1.3;
          ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384;
          ssl_prefer_server_ciphers on;
          ssl_session_cache shared:SSL:10m;
          ssl_session_timeout 10m;

          # Gzip Settings
          gzip on;
          gzip_vary on;
          gzip_min_length 1024;
          gzip_proxied any;
          gzip_comp_level 6;
          gzip_types
              text/plain
              text/css
              text/xml
              text/javascript
              application/json
              application/javascript
              application/xml+rss
              application/atom+xml
              image/svg+xml;

          # HTTP server
          server {
              listen 80;
              server_name _;

              location / {
                  root /usr/share/nginx/html;
                  index index.html index.htm;
              }

              # Health check endpoint
              location /health {
                  access_log off;
                  return 200 "healthy\n";
                  add_header Content-Type text/plain;
              }

              # Redis example endpoint
              location /redis {
                  content_by_lua_block {
                      local redis = require "resty.redis"
                      local red = redis:new()
                      red:set_timeout(1000)
                      
                      local ok, err = red:connect("redis-service", 6379)
                      if not ok then
                          ngx.say("failed to connect: ", err)
                          return
                      end
                      
                      local res, err = red:get("test")
                      if not res then
                          ngx.say("failed to get: ", err)
                          return
                      end
                      
                      ngx.say("Redis value: ", res)
                  }
              }

              # MySQL example endpoint
              location /mysql {
                  content_by_lua_block {
                      local mysql = require "resty.mysql"
                      local db, err = mysql:new()
                      if not db then
                          ngx.say("failed to instantiate mysql: ", err)
                          return
                      end
                      
                      db:set_timeout(1000)
                      
                      local ok, err = db:connect{
                          host = "mysql-service",
                          port = 3306,
                          database = "test",
                          user = "root",
                          password = "password"
                      }
                      if not ok then
                          ngx.say("failed to connect: ", err)
                          return
                      end
                      
                      local res, err = db:query("SELECT 1 as test")
                      if not res then
                          ngx.say("failed to query: ", err)
                          return
                      end
                      
                      ngx.say("MySQL result: ", res[1].test)
                  }
              }

              # JWT example endpoint
              location /jwt {
                  content_by_lua_block {
                      local jwt = require "resty.jwt"
                      local jwt_obj = jwt:verify("your-secret", ngx.var.arg_token)
                      if jwt_obj.valid then
                          ngx.say("JWT is valid: ", jwt_obj.payload)
                      else
                          ngx.say("JWT is invalid: ", jwt_obj.reason)
                      end
                  }
              }
          }

          # HTTPS server with SSL
          server {
              listen 443 ssl http2;
              server_name _;

              # SSL configuration
              ssl_certificate /etc/ssl/certs/default.crt;
              ssl_certificate_key /etc/ssl/private/default.key;

              location / {
                  root /usr/share/nginx/html;
                  index index.html index.htm;
              }

              # Health check endpoint
              location /health {
                  access_log off;
                  return 200 "healthy\n";
                  add_header Content-Type text/plain;
              }
          }
      }

  # Lua scripts configuration
  lua:
    enabled: true
    modules:
      - http
      - json
      - socket
      - ssl
      - redis
      - mysql
      - jwt
    scripts:
      # SSL certificate handler
      ssl_handler.lua: |
        local ssl = require "ngx.ssl"
        local http = require "resty.http"
        local json = require "cjson"

        local _M = {}

        function _M.handle_ssl_cert()
            local domain = ssl.server_name()
            if not domain then
                ngx.log(ngx.ERR, "No SNI name provided")
                return ngx.exit(ngx.ERROR)
            end
            
            ngx.log(ngx.INFO, "Loading SSL certificate for domain: ", domain)
            
            -- Get certificate from external service
            local cert, key = _M.get_certificate_for_domain(domain)
            if not cert or not key then
                ngx.log(ngx.ERR, "Failed to get certificate for domain: ", domain)
                return ngx.exit(ngx.ERROR)
            end
            
            -- Set the certificate
            local ok, err = ssl.set_der_cert(cert)
            if not ok then
                ngx.log(ngx.ERR, "Failed to set DER cert: ", err)
                return ngx.exit(ngx.ERROR)
            end
            
            -- Set the private key
            ok, err = ssl.set_der_priv_key(key)
            if not ok then
                ngx.log(ngx.ERR, "Failed to set DER private key: ", err)
                return ngx.exit(ngx.ERROR)
            end
            
            ngx.log(ngx.INFO, "SSL certificate loaded successfully for domain: ", domain)
        end

        function _M.get_certificate_for_domain(domain)
            local httpc = http.new()
            local res, err = httpc:request_uri("http://cert-service:8080/cert/" .. domain, {
                method = "GET",
                headers = {
                    ["Content-Type"] = "application/json"
                }
            })
            
            if not res then
                ngx.log(ngx.ERR, "Failed to request cert service: ", err)
                return nil, nil
            end
            
            if res.status ~= 200 then
                ngx.log(ngx.ERR, "Cert service returned status: ", res.status)
                return nil, nil
            end
            
            local cert_data = json.decode(res.body)
            return cert_data.cert, cert_data.key
        end

        return _M

      # Redis helper
      redis_helper.lua: |
        local redis = require "resty.redis"

        local _M = {}

        function _M.get_redis_connection()
            local red = redis:new()
            red:set_timeout(1000)
            
            local ok, err = red:connect("redis-service", 6379)
            if not ok then
                return nil, err
            end
            
            return red
        end

        function _M.get(key)
            local red, err = _M.get_redis_connection()
            if not red then
                return nil, err
            end
            
            local res, err = red:get(key)
            red:close()
            return res, err
        end

        function _M.set(key, value)
            local red, err = _M.get_redis_connection()
            if not red then
                return nil, err
            end
            
            local res, err = red:set(key, value)
            red:close()
            return res, err
        end

        return _M

      # MySQL helper
      mysql_helper.lua: |
        local mysql = require "resty.mysql"

        local _M = {}

        function _M.get_mysql_connection()
            local db, err = mysql:new()
            if not db then
                return nil, err
            end
            
            db:set_timeout(1000)
            
            local ok, err = db:connect{
                host = "mysql-service",
                port = 3306,
                database = "test",
                user = "root",
                password = "password"
            }
            if not ok then
                return nil, err
            end
            
            return db
        end

        function _M.query(sql)
            local db, err = _M.get_mysql_connection()
            if not db then
                return nil, err
            end
            
            local res, err = db:query(sql)
            db:close()
            return res, err
        end

        return _M

# Service configuration
service:
  type: LoadBalancer
  port: 80
  targetPort: 80
  annotations: {}
  https:
    enabled: true
    port: 443
    targetPort: 443

# Resources
resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

# Autoscaling
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80

# Persistence
persistence:
  enabled: true
  accessMode: ReadWriteOnce
  size: 5Gi
  storageClass: "gp2"
